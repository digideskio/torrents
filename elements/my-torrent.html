<dom-module id="my-torrent">
    <style>
        a {
            @apply(--paper-font-button);
        }

        #remove {
            color: var(--dark-accent-color);
        }

        .name {
            @apply(--paper-font-title);
        }

        .flex-horizontal {
            @apply(--layout-horizontal);
        }

        .flexchild {
            @apply(--layout-flex);
        }
    </style>
    <template>

        <paper-item class="container flex-horizontal">

            <paper-item-body two-line class="flexchild">
                <div class="name">{{ torrent.name }} - {{ torrent.size }} - {{ info.downSpeed }} - {{ info.activePeers }}/{{ info.peers }}</div>
                <div secondary>
                    <paper-progress value="{{ info.progress }}" indeterminate="{{ info.verifying }}"></paper-progress>
                    {{ info.status }}
                </div>
            </paper-item-body>

            <paper-icon-button icon="more-horiz" id="details" active="{{ showDetails }}" toggles
                               disabled="{{!torrent.loaded}}"></paper-icon-button>
            <paper-tooltip for="details">Details</paper-tooltip>

            <paper-icon-button icon="folder-open" id="open" on-click="openFolder"
                               disabled="{{!torrent.loaded}}"></paper-icon-button>
            <paper-tooltip for="open">Open</paper-tooltip>

            <paper-icon-button icon="clear" id="remove" on-click="remove"
                               disabled="{{!torrent.loaded}}"></paper-icon-button>
            <paper-tooltip for="remove">Remove</paper-tooltip>

        </paper-item>

        <div hidden$="{{ !showDetails }}">
            <template is="dom-repeat" items="{{ torrent.files }}">
                <paper-item class="container flex-horizontal">
                    <paper-item-body class="flexchild" two-line>
                        <div>{{ item.name }} - {{ item.size }}</div>
                        <div secondary>
                            <paper-progress value="{{ item.progress }}"></paper-progress>
                        </div>
                    </paper-item-body>
                </paper-item>
            </template>
        </div>

    </template>
    <script>
        'use strict';

        var humanSize = require('human-format');
        var bytes = require('pretty-bytes');
        var prettySeconds = require('pretty-seconds');
        var open = require('open');
        var fs = require('fs');
        var path = require('path');

        Polymer({
            is: 'my-torrent',
            properties: {
                torrent: Object,
                db: Object
            },
            remove: function () {
                // clean up files
                this.engine.remove();

                this.fire('remove');
            },
            openFolder: function () {
                open(this.engine.path);
            },
            ready: function () {
                var _this = this;
                _this.showDetails = false;
                _this.info = {
                    verifying: true
                };

                _this.engine = require('torrent-stream')('magnet:?xt=urn:btih:' + _this.torrent.infoHash);

                _this.engine.on('verifying', function () {
                    _this.set('info.status', 'Verifying...');
                });

                _this.engine.on('ready', function () {
                    // save metadata
                    if (!_this.torrent.loaded) {
                        _this.set('torrent.loaded', true);
                        _this.set('torrent.files', []);
                        _this.set('torrent.size', humanSize(_this.engine.torrent.length));

                        _this.engine.files.forEach(function (file) {
                            _this.push('torrent.files', {
                                name: file.name,
                                size: humanSize(file.length)
                            });
                        });

                        _this.db.write();
                    }

                    // start things up
                    _this.set('info.timeStart', (new Date()).getTime());
                    _this.set('info.verifying', false);
                    _this.engine.files.forEach(function (file) {
                        file.select();
                    });

                    // compute status
                    _this.loopStatus()
                });
            },
            loopStatus: function () {
                var _this = this;

                // progress
                var downloaded = 0;
                _this.engine.files.forEach(function (f, i) {
                    var size = fs.statSync(path.join(_this.engine.path, f.path)).size;

                    downloaded += size;

                    _this.set('torrent.files.' + i + '.progress', size * 100 / f.length);
                });
                _this.set('info.progress', downloaded * 100 / _this.engine.torrent.length);
                if (_this.info.downloaded == undefined) {
                    _this.set('info.downloaded', downloaded);
                }

                // quantity and speed
                _this.set('info.down', bytes(_this.engine.swarm.downloaded));
                _this.set('info.downSpeed', bytes(_this.engine.swarm.downloadSpeed()) + '/s');
                _this.set('info.up', bytes(_this.engine.swarm.uploaded));
                _this.set('info.upSpeed', bytes(_this.engine.swarm.uploadSpeed()) + '/s');

                // peers
                _this.set('info.peers', _this.engine.swarm.wires.length);
                _this.set('info.activePeers', _this.engine.swarm.wires.filter(function (wire) {
                    return !wire.peerChoking;
                }).length);

                // Time left = (TimeTaken / bytesDownloaded) * bytesLeft
                var bytesRemaining = _this.engine.torrent.length - _this.engine.swarm.downloaded - _this.info.downloaded;
                var status = 'Calculating';
                if (!_this.engine.amInterested) {
                    status = 'Done';
                }
                else if (_this.engine.swarm.downloaded > 0) {
                    if (_this.engine.swarm.downloadSpeed() > 0) {
                        var seconds = 1000;
                        var timeNow = (new Date()).getTime();
                        var timeElapsed = timeNow - _this.info.timeStart;
                        status = (((timeElapsed / _this.engine.swarm.downloaded) * bytesRemaining) / seconds).toPrecision(6)
                        status = 'Estimated ' + prettySeconds(~~status) + ' remaining';
                    }
                    else {
                        status = 'Unknown time remaining';
                    }
                }
                _this.set('info.status', status);

                // register next status
                setTimeout(function () {
                    _this.loopStatus();
                }, 500);
            }
        });
    </script>
</dom-module>
