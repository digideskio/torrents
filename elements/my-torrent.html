<dom-module id="my-torrent">
    <style>
        a {
            @apply(--paper-font-button);
        }

        #remove {
            color: var(--dark-accent-color);
        }

        .name {
            @apply(--paper-font-title);
        }

        .flex-horizontal {
            @apply(--layout-horizontal);
        }

        .flexchild {
            @apply(--layout-flex);
        }

        paper-progress {
            width: 100%;
        }
    </style>
    <template>

        <paper-item class="container flex-horizontal">

            <paper-item-body two-line class="flexchild">
                <div class="name">{{ torrent.name }} - {{ bytes(torrent.length) }} - {{ bytes(info.downloadSpeed) }}/s -
                    {{ info.activePeers }}/{{ info.peers }}
                </div>
                <div secondary>
                    <paper-progress value="{{ info.progress }}" indeterminate="{{ !info.ready }}"></paper-progress>
                    {{ info.status }} {{ info.estimation }}
                </div>
            </paper-item-body>

            <paper-icon-button icon="more-horiz" id="details" active="{{ showDetails }}" toggles
                               disabled="{{ !torrent.loaded }}"></paper-icon-button>
            <paper-tooltip for="details">Details</paper-tooltip>

            <paper-icon-button icon="folder-open" id="open" on-click="openFolder"
                               disabled="{{ !info.ready }}"></paper-icon-button>
            <paper-tooltip for="open">Open</paper-tooltip>

            <paper-icon-button icon="clear" id="remove" on-click="remove"
                               disabled="{{ !info.ready }}"></paper-icon-button>
            <paper-tooltip for="remove">Remove</paper-tooltip>

        </paper-item>

        <div hidden$="{{ !showDetails }}">
            <template is="dom-repeat" items="{{ torrent.files }}">
                <paper-item class="container flex-horizontal">
                    <paper-item-body class="flexchild" two-line>
                        <div>{{ item.name }} - {{ bytes(item.length) }}</div>
                        <div secondary>
                            <paper-progress value="{{ item.progress }}"></paper-progress>
                        </div>
                    </paper-item-body>

                    <paper-icon-button icon="av:play-circle-outline" id="play" on-click="play" hidden$="{{ item.isNotVideo }}"></paper-icon-button>
                    <paper-tooltip for="play">Play</paper-tooltip>
                </paper-item>
            </template>
        </div>

    </template>
    <script>
        'use strict';

        var bytes = require('pretty-bytes');
        var prettySeconds = require('pretty-seconds');
        var open = require('open');
        var fs = require('fs');
        var path = require('path');
        var mime = require('mime');

        Polymer({
            is: 'my-torrent',
            properties: {
                torrent: Object,
                db: Object
            },
            status: {
                METADATA: 'Fetching metadata...',
                VERIFYING: 'Verifying...',
                DOWNLOADING: 'Downloading...',
                SEEDING: 'Seeding'
            },
            remove: function () {
                // clean up files
                this.engine.remove();

                this.fire('remove');
            },
            openFolder: function () {
                open(this.engine.path);
            },
            play: function(event) {
                this.fire('play', this.engine.files[event.model.index]);
            },
            ready: function () {
                var _this = this;
                _this.showDetails = false;
                _this.info = {
                    status: _this.status.METADATA,
                    downloaded: 0,
                    progress: 0,
                    ready: false
                };

                _this.engine = require('torrent-stream')('magnet:?xt=urn:btih:' + _this.torrent.infoHash);

                _this.engine.on('verifying', function () {
                    _this.set('info.status', _this.status.VERIFYING);
                    _this.set('info.ready', true);

                    // save metadata
                    if (!_this.torrent.loaded) {
                        _this.set('torrent.loaded', true);
                        _this.set('torrent.files', []);
                        _this.set('torrent.length', _this.engine.torrent.length);

                        _this.engine.files.forEach(function (file) {
                            var type = mime.lookup(file.name);

                            _this.push('torrent.files', {
                                name: file.name,
                                length: file.length,
                                start: file.offset,
                                type: type,
                                isNotVideo: type.split('/')[0] != 'video'
                            });
                        });

                        _this.db.write();
                    }

                    // reset files
                    _this.engine.torrent.files.forEach(function (file, index) {
                        _this.set('torrent.files.' + index + '.downloaded', 0);
                        _this.set('torrent.files.' + index + '.progress', 0);
                    });
                });

                _this.engine.on('verify', function (index) {
                    var pieceLength = index == _this.engine.torrent.pieces.length - 1 ? _this.engine.torrent.lastPieceLength : _this.engine.torrent.pieceLength;
                    var pieceStart = index * _this.engine.torrent.pieceLength;

                    // attribute downloaded size to files
                    _this.torrent.files.forEach(function (file, index) {
                        var contained = Math.max(0, Math.min(pieceLength + pieceStart, file.start + file.length) - Math.max(file.start, pieceStart));

                        if (contained) {
                            _this.set('torrent.files.' + index + '.downloaded', file.downloaded + contained);
                            _this.set('torrent.files.' + index + '.progress', file.downloaded * 100 / file.length);
                        }
                    });

                    // compute total progress
                    if (_this.info.status == _this.status.VERIFYING) {
                        _this.set('info.downloaded', _this.info.downloaded + pieceLength);
                        _this.set('info.progress', index * 100 / _this.engine.torrent.pieces.length);
                    }
                });

                _this.engine.on('ready', function () {
                    // start things up
                    _this.set('info.timeStart', (new Date()).getTime());
                    _this.set('info.downloadedStart', _this.info.downloaded);
                    _this.set('info.status', _this.status.DOWNLOADING);
                    _this.engine.files.forEach(function (file) {
                        file.select();
                    });

                    // compute status
                    _this.loopStatus();
                });
            },
            loopStatus: function () {
                var _this = this;

                // quantity and speed
                _this.set('info.downloaded', _this.info.downloadedStart + _this.engine.swarm.downloaded);
                _this.set('info.downloadSpeed', _this.engine.swarm.downloadSpeed());
                _this.set('info.uploaded', _this.engine.swarm.uploaded);
                _this.set('info.uploadSpeed', _this.engine.swarm.uploadSpeed());

                // peers
                _this.set('info.peers', _this.engine.swarm.wires.length);
                _this.set('info.activePeers', _this.engine.swarm.wires.filter(function (wire) {
                    return !wire.peerChoking;
                }).length);

                // Time left = (TimeTaken / bytesDownloaded) * bytesLeft
                var bytesRemaining = _this.engine.torrent.length - _this.engine.swarm.downloaded - _this.info.downloadedStart;
                var estimation = 'Calculating';
                if (!_this.engine.amInterested) {
                    estimation = 'Done';
                }
                else if (_this.engine.swarm.downloaded > 0) {
                    if (_this.engine.swarm.downloadSpeed() > 0) {
                        var timeElapsed = ((new Date()).getTime() - _this.info.timeStart) / 1000;
                        estimation = ((timeElapsed / _this.engine.swarm.downloaded) * bytesRemaining).toPrecision(6);
                        estimation = 'Estimated ' + prettySeconds(~~estimation) + ' remaining';
                    }
                    else {
                        estimation = 'Unknown time remaining';
                    }
                }
                _this.set('info.estimation', estimation);

                // progress
                _this.set('info.progress', _this.info.downloaded * 100 / _this.engine.torrent.length);

                // register next status
                setTimeout(function () {
                    _this.loopStatus();
                }, 500);
            },
            bytes: function (b) {
                if (typeof b == 'undefined') {
                    return '-';
                }

                return bytes(b);
            }
        });
    </script>
</dom-module>
